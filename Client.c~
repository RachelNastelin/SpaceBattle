#include <pthread.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <stdbool.h>

#define SERVER_PORT 6663

/********************************* STRUCTS **********************************/

typedef struct update_msg{
  int clientID; // to differentiate between players
  int player_pos[][];
  bool quitting; // 0 = not quitting, 1 = quitting
  bool cannonball_shot; // 0 = didn't shoot cannonball, 1 = shot cannonball
  int direction; // LEFT, RIGHT, UP, or DOWN
} update_msg_t;


/****************************** GLOBALS **************************************/

int connections[2]; // Each index has a socket number
pthread_mutex_t connections_lock = PTHREAD_MUTEX_INITIALIZER;

/***************************** THREAD FUNCTIONS ******************************/ 
// thread to accept connections
void * accept_connections_func (void * listen_socket_num) {
  int socket = *(int*)listen_socket_num;
  free(listen_socket_num);

  // Repeatedly accept connections
  while(continue_flag) {
    // Accept a client connection
    struct sockaddr_in client_addr;
    socklen_t client_addr_len = sizeof(struct sockaddr_in);
    int client_socket = accept(socket, (struct sockaddr*)&client_addr,
                               &client_addr_len);
    pthread_mutex_lock(&list_lock);
    // add the new connection to our list of connections
    connect_list_t* new_child = (connect_list_t*)malloc(sizeof(connect_list_t));
    new_child->socket = client_socket;
    new_child->next = connections;
    connections = new_child;
    pthread_mutex_unlock(&list_lock);

    // create a listen and relay thread for the new connection
    pthread_t listen_thread;
    int * socket_num = (int*)malloc(sizeof(int));
    *socket_num = client_socket;
    if(pthread_create(&listen_thread, NULL, listen_relay_func,
                      (void*)socket_num)) {
      perror("pthread_create failed");
      exit(EXIT_FAILURE);
    } // if  
  } // while
} // accept_connections_func


/*************************** HELPER FUNCTIONS ********************************/
// remove a connection from our list
void remove_connection (int socket) {
  pthread_mutex_lock(&list_lock);
  connect_list_t * current = connections;
  connect_list_t * previous = NULL;
  while (current->socket != socket) {
    previous = current;
    current = current->next;
  } // while
  if (previous == NULL) {
    connections = current->next;
  } else {
    previous->next = current->next;
  } 
  free(current);
  pthread_mutex_unlock(&list_lock);
} // remove_connection
